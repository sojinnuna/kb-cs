## 4. HTTP에 대해 설명해 주세요.
- HTTP(HyperText Transfer Protocol)
  
	인터넷 상에서 클라이언트와 서버가 자원을 주고 받을 때 쓰는 통신 규약
	- HTTP/1.1
  
		평문 기반 프로토콜
	- HTTP/2.0
  
		바이너리 기반 프로토콜
		특징 : 
		바이너리 데이터로 이루어져 있어 빠르고 효율적이면 네트워크 친화적입니다. 
		구문 분석에 효율적 > 바이너리 데이터 인코딩/디코딩 처리 속도가 문자열 데이터의 인코딩/ 디코딩 처리 속도보다 빠름
		
		- **HTTP1.1도 결국 바이너리 데이터로 변환되는 거 아닌가요?**
  
			HTTP1.1도 네트워크에선 바이너리로 변환되어 전송됩니다. 다만 HTTP2.0은 바이너리 프레이밍 계층을 어플리케이션 레이어 부분에 구현하여 데이터를 전송하기 전에 바이너리 프레임으로 변환됩니다. 때문에 헤더 부분이 압축되고, 바이너리 프레이밍 부분에서 다중화가 가능해집니다. (하나의 헤더 프레임 + 여러 개의 데이터 프레임)

      - __HTTP/3.0 이전 버전 HTTP 프로토콜의 문제점...__
        - HTTP HOLB(head of line blocking)
  
            HTTP/1.1 이전의 요청/응답은 동기적으로 진행됐습니다. 즉,  1. 사진을 요청 -> 응답 -> 2. css 파일을 요청 -> 응답 ... 이런 식으로 작동합니다.
            이를 개선한기 위해 HTTP 1.1은 pipelining이란 개념을 도입했습니다. pipelining이란 응답을 기다리지 않고 요청을 미리 보내는 것입니다. 1. 사진을 요청 > 1-1. css 파일을 요청 => 사진 응답, css 응답 ... 와 같이 작동합니다.
            한계점 :
            그래도 요청은 순서대로 처리된다는 단점이 존재했는데 이를 HOLB 문제라 합니다.

                line => 데이터 패킷, head는 데이터 패킷의 맨 앞, blocking은 운영체제의 I/O blocking과 비슷하다 생각하시면 이해하기 편합니다.
        위의 HOLB는 HTTP/2.0에서 해결됩니다. 멀티플렉싱이란 개념을 도입하여 요청/응답을 병렬적으로 처리합니다.
        > 멀티플렉싱이란? 하나의 TCP 연결에서 여러 스트림을 동시에 처리할 수 있게 해주는 기술

        그러나 TCP 단의 HOLB는 해결하지 못했습니다(~HTTP/2.0은 TCP 위에서 작동)
        - TCP HOLB
  
            TCP 상에서 전송된 패킷이 손실되면 재전송을 합니다. 이 때 TCP 순서를 보장해주기 위해 후속 패킷들은 대기하게 됩니다. -> Blocking
          - 순서 보장을 위해선 막아야 되는 거 아닌가요?
  
            서로 연관된 패킷은 순서보장을 위해 순차적으로 처리해야합니다. 하지만 TCP HOLB는 해당 스트림을 막는다는 것이 문제입니다. 그래서 연관되지 않은 패킷들도 blocking 됩니다.
          -  TCP를 여러개 사용하면 되는 거 아닌가요?
  
            TCP는 연결할 때마다 3-way handshake를 수행하는데 이는 지연 시간을 증가시키고 오버헤드가 생깁니다.
        
        __이를 해결하기 위해 HTTP/3.0은 UDP기반인 QUIC 프로토콜을 사용합니다__
	- HTTP/3.0
        

- HTTPS(Hypertext Transfer Protocol Secure)
  
	HTTP를 암호화 시킨 것
	- 왜 암호화를 시켜야 합니까?
  
		HTTP를 평문으로 보낼 경우 목적지에 도달하기 위해 수 많은 라우터와 스위치를 거쳐가게 되는데, 이 때 타인이 내 민감한 데이터를 쉽게 도청할 수 있습니다. (스니핑) 
		
	- 어떻게 암호화 시키나요?
  
		TLS(Transport Layer Security)를 사용하여 암호화시킵니다. TLS는 대칭키 + 공개키(비대칭키) 방식을 사용하여 암호화합니다. 
		CA는 인증서를 신뢰가 가능하도록 보장합니다.
		1. 서버는 CA에게 서버 공개키를 전달하여 인증서를 발급받습니다. 
		2. 서버는 클라이언트와 연결을 수립할 때 이 인증서를 전달합니다. 
		3. 클라이언트는 브라우저에 저장된 CA 공개키로 인증서를 복호화하여 서버의 공개키를 획득합니다. 
		4. 이 과정을 통해 연결이 수립되면 클라이언트는 서버의 공개키를 사용하여 세션 키(대칭키)를 암호화하고 이를 서버에 전송합니다. 서버는 자신의 개인키로 이 암호화된 세션 키를 복호화하여 대칭키를 얻습니다.
		5. 대칭키를 사용하여 데이터를 암호화하고 이를 주고 받습니다.
     - 처음 서버에서 클라이언트로 인증서를 보낼 때 공격자가 인증서를 가로채면 대칭키가 탈취되는 거 아닌가요?
  
		인증서는 인증서 공개키로 복호화할 수 있습니다. 인증서 안에는 서버 공개키가 있는데, 클라이언트는 이 서버 공개키를 사용해서 대칭키를 암호화합니다. 서버의 공개키로 암호화된 데이터는 서버의 개인키로만 복호화가능합니다. 때문에 인증서가 탈취되도 HTTPS 데이터는 안전합니다. 
     - 공개키와 대칭키에 대해 설명해 주세요.

    	1. 공개키 : 암호화, 복호화에 사용되는 키가 서로 다릅니다. 비대칭키라고도 불립니다. 서버가 가진 키는 개인키이고 클라이언트들이 갖는 키가 공개키입니다.

      	2. 대칭키 : 암호화, 복호화에 사용되는 키가 서로 같습니다
		
    	- 공개키에서 서버와 클라이언트의 키가 서로 다르면 어떻게 암호화 복호화 할 수 있을까요?
  
    		2개의 키중 하나를 공개하고, 하나는 서버에서 사용합니다. 암호화 알고리즘을 사용해서 서버의 개인키는 클라이언트가 공개된 키로 암호화된 데이터를 복호화할 수 있습니다.

		
	
- 왜 HTTPS Handshake 과정에서는 인증서를 사용하는 것 일까요?
  
	사용자에게 접속하려는 서버가 신뢰 가능하다는 것을 증명하기 위해 사용됩니다.
	- 인증서가 뭐길래 어떻게 신뢰할 수 있나요?
  
		인증서란 CA(Certificate Authority, 인증 기관)라는 곳에서 발급하는 공인된 인증서입니다.
	- 서버가 인증서를 발급하는 주체가 될 수 없나요?
  
		서버도 자체 인증서를 발급할 수 있습니다(mkcert). 이를 발급받아 local 개발 환경에서 https를 사용할 수 있습니다. 로컬 서버를 배포 서버와 비슷한 환경에서 테스트하면 개발에 유리합니다. 또한 http를 사용했을 때 기능이 제한되는 라이브러리들도 있으니 요구사항에 따라 local도 https 환경으로 개발해야합니다.
- SSL과 TLS의 차이는 무엇인가요?
  
	SSL의 향상된 버전이 TLS입니다. 현재 SSL은 모두 TLS에 대체되었지만 SSL이라는 용어는 아직도 많이 사용됩니다. 하지만 이는 거의 TLS를 지칭하는 말입니다.


- 보안이 중요하면 다른 프로토콜들은 어를 어떻게 지원하나요

	노출되고 싶지 않은 데이터, 노출되면 안되는 데이터(로그인 정보, 개인 정보 등)들에는 보안이 필요합니다. 특히 로그인을 사용하는 프로토콜의 경우 특히 보안을 더 신경써야합니다. 
  
  1. SSH(시큐어 쉘) : 다른 컴퓨터에 원격 접속을 지원합니다. 특히 클라우드 서비스(AWS, Vultr 등)에 사용됩니다. 이와 같이 원격으로 접속할 때 보안이 적용되지 않은 Telnet 프로토콜을 사용하면 안됩니다.
  2. SFTP(SSH FTP) : 다른 컴퓨터에 파일을 전송합니다. 사용자 인증 
