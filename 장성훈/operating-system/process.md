### 프로세스가 무엇인가요?

프로세스는 실행 중인 프로그램의 인스턴스로, 실행되는 프로그램 코드, 데이터, 실행 상태(레지스터, 스택 등)를 포함합니다. 프로세스는 독립적인 실행 단위로서 CPU 스케줄링의 대상이 됩니다.

### **프로그램과 프로세스, 스레드의 차이에 대해 설명해 주세요.**

- **프로그램**:
    
    파일이 저장 장치에 저장되어 있지만 메모리에는 올라가 있지 않은 정적인 상태 (코드 덩어리 파일)
    
    - 디스크에 저장된 실행 가능한 파일을 말하며, 실행하기 위해서는 메모리에 로드되어야 합니다.
- **프로세스**:
    
    운영체제로부터 자원을 할당받은 작업의 단위. (코드 덩어리 파일을 실행한 것)
    
    - 실행 중인 프로그램을 의미하며, 프로그램이 실행되어 메모리에 올라가면 운영 체제는 이를 프로세스로 관리합니다.
    - 프로세스는 프로그램의 코드를 실행하기 위해 필요한 모든 리소스, 즉 CPU 시간, 메모리, 파일 핸들 등을 포함합니다. (= PCB)
    - 각 프로세스는 독립된 메모리 공간을 가지며, 다른 프로세스와 메모리 공간을 공유하지 않습니다. 이를 통해 프로세스 간의 간섭을 방지하고 안정성을 보장합니다.
- **스레드**:
    - 프로세스가 할당받은 자원을 이용하는 실행 흐름의 단위.
    - 하나의 프로세스는 여러 개의 스레드를 가질 수 있으며, 이 스레드들은 동일한 메모리 공간을 공유합니다.
        
        ex) 크롬에서 탭마다 별도의 스레드를 사용 ← 서로의 메모리에 접근
        
    - 스레드 간의 통신을 빠르게 하지만, 동시에 동기화 문제에 대한 주의가 필요합니다.
        

        

### **PCB가 무엇인가요?**

PCB(Process Control Block)는 운영체제가 각 프로세스를 관리하기 위해 사용하는 자료 구조입니다. PCB는 프로세스의 상태, 프로그램 카운터, CPU 레지스터, 메모리 관리 정보, I/O 상태 정보, 계정 정보 등 프로세스와 관련된 모든 정보를 포함합니다.

- 정보
    - **포인터**
        
        프로세스의 현재 위치를 저장하는 포인터 정보입니다.
        
    - **프로세스 상태**
        
        프로세스의 각 상태 (생성(New), 준비(Ready), 실행(Running), 대기(Waiting), 종료(Terminated))를 저장합니다.
        
    - **프로세스 번호**
        
        모든 프로세스에는 프로세스 식별자를 저장하는 프로세스 ID 또는 PID라는 고유 한 ID가 할당됩니다.
        
    - **프로그램 카운터**
        
        프로세스를 위해 실행될 다음 명령어의 주소를 포함하는 카운터를 저장합니다.
        
    - **레지스터**
        
        누산기, 베이스, 레지스터 및 범용 레지스터를 포함하는 CPU 레지스터에 있는 정보입니다.
        
    - **메모리 제한**
        
        이 필드에는 운영 체제에서 사용하는 메모리 관리 시스템에 대한 정보가 포함됩니다. 여기에는 페이지 테이블, 세그먼트 테이블 등이 포함될 수 있습니다.
        
    - **열린 파일 목록**
        
        이 정보에는 프로세스를 위해 열린 파일 목록 이 포함됩니다.
        
        
        
- PCB는 프로세스 생성 시 만들어지며 주기억장치에 유지됩니다.
- 프로세스 상태 관리와 문맥교환(Context Switching)을 위해 필요합니다.
    
    → 수행 중인 프로세스를 변경할 때 레지스터에 프로세스의 정보가 바뀌는 것
    
    → **CPU가 이전의 프로세스 상태를 PCB에 보관하고, 또 다른 프로세스의 정보를 PCB에서 읽어 레지스터에 적재하는 과정**
    

### **그렇다면, 스레드는 PCB를 갖고 있을까요?**

스레드는 독립적인 PCB를 갖지 않지만, 각 스레드는 TCB(Thread Control Block)라는 구조를 가집니다. TCB는 스레드의 상태, 프로그램 카운터, 레지스터, 스택 포인터 등의 정보를 저장합니다. 스레드는 같은 프로세스 내에서 메모리와 자원을 공유하지만, 독립적인 실행 상태를 유지합니다.

### **리눅스에서, 프로세스와 스레드는 각각 어떻게 생성될까요?**

- **프로세스 생성**: `fork()` 시스템 콜을 통해 부모 프로세스를 복제하여 자식 프로세스를 생성합니다. `exec()` 시스템 콜을 통해 새로운 프로그램을 실행할 수 있습니다.
- **스레드 생성**: `pthread_create()` 함수를 사용하여 새로운 스레드를 생성합니다. 리눅스에서는 스레드도 일종의 경량 프로세스(Lightweight Process)로 취급됩니다.

### **자식 프로세스가 상태를 알리지 않고 죽거나, 
부모 프로세스가 먼저 죽게 되면 어떻게 처리하나요?**

- 자식 프로세스가 상태를 알리지 않고 종료되면, 좀비 프로세스가 됩니다. 좀비 프로세스는 PCB만 남아 자원을 소모합니다.
    
    만약, `wait()` 또는 `waitpid()` 호출을 통해 자식 프로세스의 종료를 기다리지 않고 부모 프로세스가 종료될 경우에는 자식 프로세스는 좀비 상태로 남아있게 됩니다.
    
- 부모 프로세스가 먼저 종료되면, 자식 프로세스는 고아 프로세스가 됩니다. 고아 프로세스는 init 프로세스(PID 1)가 새 부모 프로세스로 인계받아 관리하게 됩니다.
    
    (init process = 시스템이 부팅될 때 커널에 의해 처음으로 생성되는 프로세스, 다른 모든 프로세서스들은 init 프로세스로부터 파생됨)
    
    ```java
    init (PID 1)
     ├─ Process A
     │   ├─ Process A1
     │   └─ Process A2
     └─ Process B
         ├─ Process B1
         └─ Process B2
    ```
    
- 자식 프로세스가 부모 프로세스와 독립적으로 수행될 수 있는 작업을 하는 경우, 부모 프로세스가 자식 프로세스를 기다리지 않아도 됩니다.
    
    ex) 자식 프로세스가 데몬 프로세스나 백그라운드 작업같이 독립적으로 수행될 경우
    
    부모 프로세스가 특정 작업을 완료한 후에 즉시 종료되어야만 하는 경우
    

### **리눅스에서, 데몬프로세스에 대해 설명해 주세요.**

데몬 프로세스는 **시스템에서 백그라운드에서 실행**되는 프로세스로, 특정 서비스나 작업을 수행합니다. 예를 들어, 웹 서버, 데이터베이스 서버 등이 데몬 프로세스로 실행됩니다. 데몬 프로세스는 일반적으로 시스템 부팅 시 시작되며, 터미널이나 **사용자와 직접 상호작용하지 않습**니다. 주로 서버 프로세스, 로그 관리, 시스템 모니터링 등의 역할을 수행합니다.

- 터미널이나 사용자 인터페이스와 상호작용하지 않고 백그라운드에서 실행
- 부모 프로세스로부터 독립적으로 실행, PID 1이 부모가 되어 관리
- 웹 서버(예: Apache, Nginx), 데이터베이스 서버(예: MySQL), 프린터 스풀러(예: CUPS) 등
    
    {suffix} + ‘d’의 구조로 네이밍 (mongod, mysqld, httpd 등)
    

- PPID를 1혹은 다른 데몬 프로세스 (Parent Process ID)
    
    ⇒ init 프로세스 or 데몬 프로세스(systemd, upstart, supervisord 등)의 PID
    
### **리눅스는 프로세스가 일종의 트리를 형성하고 있습니다. 이 트리의 루트 노드에 위치하는 프로세스에 대해 설명해 주세요.**

리눅스에서 모든 프로세스의 루트 노드는 `init` 프로세스(PID 1)입니다. `init` 프로세스는 시스템 부팅 시 커널에 의해 최초로 생성되며, 다른 모든 프로세스의 부모 역할을 합니다. 현대 리눅스 시스템에서는 `systemd`가 `init` 프로세스를 대체하여 시스템과 서비스 관리를 담당합니다. `init` 또는 `systemd`는 고아 프로세스를 인계받아 관리하며, 시스템 종료 시까지 실행됩니다.

---
