## HTTP/1.1
  
평문 기반 프로토콜입니다.
- Pipelining
 
  클라이언트가 서버에 다수의 요청을 보내고 서버는 응답을 차례대로 반환합니다.  
   이를 통해 네트워크 대기 시간을 줄이고 효율성을 높입니다.
> instruction pipeline : 프로세서가 하나의 명령어를 실행하는 도중에 다른 명령어를 실행하는 기법, 여러개의 명령어를 동시에 수행한다.
 
 - Persistence Connection
  
    단일 TCP 연결을 통해 여러 HTTP 요청을 연속적으로 보낼 수 있습니다.  
     이를 통해 각 요청마다 새로운 연결을 설정하는 오버헤드를 제거하여 응답 속도를 개선합니다.
 > HTTP/1.0에서는 HTTP Header에 Connection: keep-alive을 붙여야 해당 기능을 지원해줬다.

 - Chunked transfer encoding
  
   서버는 응답 데이터를 청크로 나누어 전송할 수 있습니다.  
  이는 서버가 응답 전체를 준비하지 않고도 클라이언트로 데이터를 전송할 수 있게 하여 전송 속도를 향상시킵니다.

 - Host Header
   Header에 Host를 추가하여 하나의 IP나 서버가 여러 도메인을 쓸 때 Host Header를 통해 어느 도메인으로 들어왔는지 알려줍니다.

## HTTP/2.0

바이너리 기반 프로토콜입니다.
바이너리 데이터로 이루어져있습니다.  
헤더와 바디가 레이어로 구분됩니다.  
구문 분석에 효율적입니다  
바이너리 데이터 인코딩/디코딩 처리 속도 **>** 문자열 데이터의 인코딩/ 디코딩 처리 속도

HTTP/1.1에선 요청과 응답이 Message 단위로 구성되어 있었습니다.
HTTP/2.0에선 Message외에 Frame, Stream 개념이 추가되었습니다.
Stream은 하나의 Tcp 연결위에서 Stream을 구성하여 여러개의 Frame을 보낼 수 있고, 또한 하나의 TCP 연결에서 여러개의 Stream을 구성할 수 있습니다.
이것을 Multiplexing이라 합니다.
- Multiplexing
  
**여러개의 Stream이 구성되어있다고 하지만, TCP 연결이 하나인 경우 여전히 물리적으론 하나의 연결입니다**
> [TCP 연결]  
| Stream A: Header Frame | Stream B: Header Frame | Stream A: Data Frame | Stream B: Data Frame | Stream A: Data Frame | ...

  * 레이어에 따른 용어 
    
|레이어|PDU|
  |---|-----|
  |애플리케이션|메시지|
  |전송|세그먼트(TCP), 데이터그램(UDP)|
  |인터넷|패킷|
  |링크|프레임(데이터 링크), 비트(물리 계층)|
  >바이너리는 Bianry Digits(bits)라고도 불림

- Server push
  클라이언트가 요청하지 않은 데이터를 서버에서 미리 보내 브라우저에 캐싱해놓는 기능입니다.
  최적화 기법이 없는 GET 요청에서는 브라우저가 응답받은 HTMl 문서를 순차적으로 읽을 때 외부 리소스를 발견하면 다시 요청을 보냅니다.

  HTTP/2.0의 Server push를 사용하면 HTML 문서에 필요한 리소스들을 미리 파악해서 클라이언트에게 보냅니다.
  
  ![](https://blog.apnic.net/wp-content/uploads/2018/04/HTTP2_1.png)

  - Selectively Push
  HTTP/2.0은 리소스를 푸시할지 여부를 결정하는 것에 대해 다루지 않습니다.   
  즉, Server Push는 클라이언트가 리소스를 필요로 할 가능성이 높고 이미 캐시되어 있지 않을 경우에만 리소스를 푸시하는 것이 가장 좋습니다.   
  브라우저에 캐시되어 있는데 응답을 보내면 낭비겠죠.   
  한 가지 가능한 접근 방법은 클라이언트가 사이트를 처음 방문할 때만 리소스를 푸시하는 것입니다.
  예를 들어 세션 쿠키의 존재 여부를 테스트하고, 조건부로 Link 헤더를 설정하여 세션 쿠키가 없는 경우에만 리소스를 pre load할 수 있습니다.
  이 방법을 사용하면 GET 요청의 2RTT를 1RTT로 줄일 수 있습니다.

- Stream Prioritization
  
  스트림들의 우선순위를 1~256의 가중치를 할당하여 정해줍니다.  
  용량이 크고 중요하지않은 데이터를 후순위로 미룰 수 있게 합니다.
- **HTTP1.1도 결국 바이너리 데이터로 변환되는 거 아닌가요?**

  HTTP1.1도 네트워크에선 바이너리로 변환되어 전송됩니다.  
  다만 HTTP2.0은 바이너리 프레이밍 계층을 어플리케이션 레이어 부분에 구현하여 데이터를 전송하기 전에 바이너리 프레임으로 변환됩니다.  
  때문에 헤더 부분이 압축되고, 바이너리 프레임 부분에서 다중화가 가능해집니다. (하나의 헤더 프레임 + 여러 개의 데이터 프레임)


------------------
## __HTTP/3.0 이전 버전 HTTP 프로토콜의 문제점...__
      
  - HTTP HOLB(head of line blocking)

      HTTP/1.1 이전의 요청/응답은 동기적으로 진행됐습니다. 
      > 사진을 요청 > 응답 > 2. css 파일을 요청 > 응답 ... 이런 식으로 작동합니다.

      이를 개선한기 위해 HTTP 1.1은 pipelining이란 개념을 도입했습니다.  
      pipelining이란 응답을 기다리지 않고 요청을 미리 보내는 것입니다. 
      >  사진을 요청 > css 파일을 요청 > 사진 응답, css 응답 ... 와 같이 작동합니다.

      그러나 pipelinig을 적용해도 요청에 대한 응답 순서대로 처리되었어야 했습니다.  
      이를 HOLB 문제라 합니다.

            line => 데이터 패킷, head는 데이터 패킷의 맨 앞, blocking은 운영체제의 I/O blocking과 비슷하다 생각하시면 이해하기 편합니다.
    위의 HOLB는 **HTTP/2.0**에서 해결됩니다.  
    Multiplexing이란 개념을 도입하여 요청/응답을 병렬적으로 처리합니다.
    > Multiplexing이란? 하나의 TCP 연결에서 여러 스트림을 동시에 처리할 수 있게 해주는 기술

    그러나 TCP 단의 HOLB는 해결하지 못했습니다(HTTP/2.0까지의 HTTP는 TCP 위에서 작동)
    - TCP HOLB

        TCP 상에서 전송된 패킷이 손실되면 재전송을 합니다. 이 때 TCP 순서를 보장해주기 위해 후속 패킷들은 대기하게 됩니다. -> Blocking  
        패킷들은 TCP Buffer에서 다시 재조립됩니다. 이때 어느 한 패킷에 loss가 발생하면 그 뒤에 있는 패킷은 버퍼에 저장되어 있지만 처리되지 못하고 대기상태에 있게 됩니다. 
      - 순서 보장을 위해선 막아야 되는 거 아닌가요?

        서로 연관된 패킷은 순서보장을 위해 순차적으로 처리해야합니다.  
        하지만 TCP HOLB는 해당 스트림을 막는다는 것이 문제입니다.  
        그래서 연관되지 않은 패킷들도 blocking 됩니다.  
    위는 TCP 프토로콜의 특성과 관련되어 있고, TCP는 신뢰할 수 있는 전송을 위해 패킷의 순서를 보장해야합니다.  

    __이를 해결하기 위해 HTTP/3.0은 UDP기반인 QUIC 프로토콜을 사용합니다__



## HTTP/3.0
TCP의 Handshake, TCP의 HOLB(순서 보장)의 latency를 해결하기 위해 나온 프로토콜
GOOGLE의 QUIC 프로토콜을 기반으로 사용합니다.
  - QUIC 프로토콜  
  QUIC은 어플리케이션 레이어 일부, TLS 레이어 포함, 그리고 전송 계층 일부에 구현되어 있습니다.   
  TLS 레이어를 포함하기 때문에 TLS를 통한 HTTPS가 필수적으로 요구됩니다.
  또한 HTTP/2.0의 멀티플렉싱 등 대부분 기능이 QUIC 프로토콜에 구현되어 있습니다.
  
- RTT 시간 감소  
  기존의 HTTP는 TCP Handshake, TLS Handshake를 사용하여 2 RTT의 시간이 소요되었는데, QUIC은 UDP위에서 구현되어 TLS layer를 합쳐 이를 1 RTT or 0 RTT로 해결합니다.
  - 왜 TCP를 수정하거나 프로토콜을 새로 만들지 않고 UDP 위에서 구현되었나요?
    새로운 전송 프로토콜을 만드는 것은 힘듭니다. 보안을 위해 네트워크 중간에 있는 개체들이 친숙하지않은 프로토콜을 막을 수 있고, 방화벽이나 라우터들에 의해 막힐 가능성이 있습니다. TCP를 수정하는 것도 힘듭니다. TCP는 OS 커널에 구현되어 있는데 이를 수정하면 모든 장비들의 OS가 업데이트 되어야 합니다. 이는 수십년이 걸릴 수도 있는 일입니다. 
- TCP HOLB 문제 완화  
  HTTP/3.0의 스트림은 독립적으로 운영되기 때문에 하나의 스트림이 막혀도 다른 스트림에 영향을 주지 않습니다.
  packet loss되어도 해당 packet의 스트림만 막히고 다른 스트림에는 영향이 없습니다. (스트림마다 버퍼가 생김)
      
