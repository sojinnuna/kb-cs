### 4-Way Handshake
클라이언트와 서버가 세션을 종료하기 위해 수행되는 절차입니다.   
TCP는 두 가지 연결 해제 방식이 있습니다.
- 정상적인 연결 종료 : 4-Way Handshake(Fin 플래그)를 사용한 단계별 종료
- 비정상적인 연결 종료 : RST 플래그를 사용한 즉시 종료

- 4-Way Handshake
  
![4wayhandshake](https://github.com/user-attachments/assets/aa81a556-9979-45af-bfd3-848e3421870f)
  
  정상적으로 연결이 해제될 때 사용됩니다. 클라이언트와 서버는 4번 패킷을 주고 받아서 신뢰성 있는 연결 종료를 보장합니다.  
  - 사전 조건
>>>>>>> 7afce10bdaeb7d4f96d27f58f64dc234cb04f009
  클라이언트와 서버의 TCP 상태는 서로 established 상태여야 합니다.
  - 동작 방식
    1. 클라이언트가 연결은 종료하려고 할 때, FIN 플래그가 설정된 세그먼트를 서버에 보냅니다.
    2. 서버는 FIN 세그먼트를 받고, ACK 세그먼트를 클라이언트에 보냅니다.
    3. 서버도 종료할 준비가 되었다면 FIN 세그먼트를 클라이언트에 보냅니다.
       - 종료할 준비란?   
    서버가 FIN을 보내기 전에 처리해야할 일이 있습니다. 클라이언트가 요청한 정보를 모두 보내야되고, 자신의 버퍼를 비워야합니다. 이 과정을 마치면 서버는 종료할 준비가 되었습니다.
    4. 클라이언트는 ACK 세그먼트를 서버로 보냅니다.
    5. 이후 과정  
    서버는 ACK 세그먼트를 받고 CLOSED됩니다.(connection socket closed)   
    클라이언트는 TIME-WAIT 상태에 들어갑니다. double MSL(Maximum segment lifetime)동안 기다리며 네트워크에 존재하는 TCP 세그먼트를 기다립니다. 이 시간이 지나면 소켓이 close 됩니다.

###  4-Way Handshake에 대해 설명해 주세요.
- 패킷이 4-way handshake 목적인지 어떻게 파악할 수 있을까요?   
  서버는 수신받은 세그먼트의 TCP 제어 플래그가 FIN이면 4-way handshake를 위한 패킷으로 볼 수 있습니다. 또한 클라이언트는 서버가 전송한 ACK 세그먼트의 시퀀스 넘버가 자신이 보낸 시퀀스보다 1 크다면 4-way handshake의 ack 패킷인지 알 수 있습니다.  Fin 세그먼트를 시작으로 각 세그먼트의 시퀀스 넘버 값을 비교하여 4-way handshake의 목적을 띄는지 확인합니다.   
- 빨리 끊어야 할 경우엔, (즉, 4-way Handshake를 할 여유가 없다면) 어떻게 종료할 수 있을까요?   
  TCP 세그먼트의 제어 플래그 중 RST 플래그를 설정하여 보냅니다.
- 4-Way Handshake 과정에서 중간에 한쪽 네트워크가 강제로 종료된다면, 반대쪽은 이를 어떻게 인식할 수 있을까요?   
  - RST 패킷   
  자신이 강제로 종료되면 상대방에게 RST 패킷을 보내 연결 종료를 알립니다. 
  - Keep-Alive 패킷   
  Keep-Alive 옵션을 활성화하면 일정 시간 간격으로 Keep-Alive 패킷을 보내 상대방의 응답을 기다립니다.   
  여러번 보냈지만 응답이 없으면 연결이 끊어졌다 간주합니다.

  - Time Out   
  상대방에게 패킷을 보냈는데, 특정 시간 동안 응답이 없으면 타임 아웃을 늘려 다시 보냅니다. 이를 여러번 시도하다가 끝내 응답이 안오면 연결이 끊어진 것으로 간주합니다.   
- 왜 종료 후에 바로 끝나지 않고, TIME_WAIT 상태로 대기하는 것 일까요?   
  클라이언트가 바로 종료되면 네트워크에서 지연된 패킷이 유실될 수 있습니다. 클라이언트는 TIME_WAIT 상태에서 대기하는 동안 이러한 패킷이 도달되길 기다립니다. 또한 새로운 연결이 방금 종료된 연결의 포트를 사용할 수도 있는데, 이 때 TIME_WAIT이 없다면 지연 패킷이 새로운 연결에 영향을 끼칠 수도 있습니다.   
  때문에 TCP는 데이터 무결성과 안정성을 위해 종료되어도 double MSL 동안 TIME_WAIT 상태로 대기하도록 합니다.    


