## 교착 상태(데드락, Deadlock)

교착 상태(Deadlock)는 두 개 이상의 작업이나 프로세스가 서로의 작업 완료를 기다리며 무한정 멈춰있는 상태를 의미합니다. 이 문제는 주로 운영 체제, 데이터베이스 관리 시스템, 멀티스레딩 프로그래밍 등에서 발생하며, 시스템의 효율성과 안정성을 저해할 수 있습니다. 교착 상태가 발생하면 시스템은 정상적으로 작동하지 못하게 되므로 이를 이해하고 예방하는 것이 중요합니다.

### 교착 상태의 조건

교착 상태가 발생하려면 다음 네 가지 조건이 동시에 만족되어야 합니다.

1. **상호 배제 (Mutual Exclusion)**
    
    자원은 한 번에 하나의 프로세스만 사용할 수 있어야 합니다.
    
2. **점유와 대기 (Hold and Wait)**
    
    자원을 점유한 상태에서 다른 자원을 기다리는 프로세스가 존재합니다.
    
3. **비선점 (No Preemption)**
    
    프로세스에 할당된 자원을 다른 프로세스가 강제로 빼앗을 수 없습니다.
    
4. **순환 대기 (Circular Wait)**
    
    프로세스들이 순환 형태로 자원을 기다립니다.
    

## 교착 상태를 피하는 법

- 데드락이 발생하지 않도록 **예방**(prevention)
- 데드락 발생 가능성을 인정하면서도 적절하게 **회피**(avoidance)
- 데드락 발생을 허용하지만 데드락을 **탐지**(detection)하여, **데드락에서 회복**(Recovery)

### 1. 예방 (Prevention)

- 교착상태가 발생할 수 있는 요구조건을 만족시키지 않게 함으로써 교착상태를 방지한다.
- 위에 있는 교착상태 발생의 네가지 조건 중에서 어느 하나를 제거함으로써 수행된다.
- 자원 낭비가 가장 심한 기법이다.

### 2. 회피 (Avoidance)

- 교착 상태를 회피하기 위해 시스템이 안전 상태에서만 자원을 할당하는 방법이다.
- 리소스 할당의 측면에서, 교착상태가 발생할 가능성이 있는 자원 할당(unsafe allocation)을 하지 않는다.
- 주로 **은행원 알고리즘(Banker's Algorithm)**이 사용된다.
• 은행원 알고리즘은 다익스트라가 제안한 기법으로, 은행에서 모든 고객의 요구가 충족되도록 현금을 할당하는데서 유래한 기법

### 3. 탐지 및 회복 (Detection and Recovery)

- 교착 상태를 탐지하고 이를 회복하는 방법이다.
- 탐지
    - 시스템에 교착상태가 발생했는지 점검하여 교착상태에 있는 프로세스와 자원을 발견한다.
    - 교착 상태를 탐지하기 위해 교착상태 발견 알고리즘과 자원 할당 그래프 등을 사용한다.
- 회복
    - 교착 상태가 발견되면 이를 회복하기 위해 프로세스를 중단시키거나, 일부 자원을 강제로 회수한다.
    - 교착상태가 발생 할 수 있도록 놔 두고 교착상태가 발생 할 경우 찾아내어 고친다.

### 4. 비처리 (Ignoring the Problem)

- 교착 상태를 명시적으로 처리하지 않음
- 교착 상태가 드물게 발생하거나, 발생 시 시스템 재부팅 등의 간단한 방법으로 해결할 수 있는 경우에 사용
- 교착 상태 관리의 복잡성과 오버헤드를 최소화

## 왜 3가지만 충족하면 교착상태가 아닌가?

Deadlock 발생에 필요한 조건이 4가지 중 하나인 "순환 대기(Circular Wait)" 조건이 포함되어 있기 때문입니다. 순환 대기 예를 들어,

1. 상호 배제 조건이 없으면 두 개 이상의 프로세스가 동시에 자원을 사용할 수 있으므로, 대기할 필요가 없어짐
2. 점유 및 대기 조건이 없으면 자원을 요청한 프로세스는 해당 자원을 할당받지 못하고 바로 실패하게 되므로 대기X
3. 비선점 조건이 없으면 다른 프로세스가 자원을 강제로 해제할 수 있으므로, 프로세스들이 서로 계속해서 자원을 해제하고 점유할 수 있게 됨

따라서, 세 가지 조건만 충족된다면 순환 대기 조건이 없어서 Deadlock이 발생하지 않으며, 순환 대기 조건이 포함된 경우 4가지 조건이 모두 충족되어야 Deadlock이 발생합니다.

## Lock-Based, Lock-Free, and Wait-Free Programs

**Lock-Based, Lock-Free, and Wait-Free Programs**는 동시성 제어를 위해 다양한 접근 방식을 사용하는 프로그램 유형입니다:

1. **Lock-Based Programs**:
    
    동기화를 위해 잠금(Lock)을 사용하는 프로그램입니다. 이 방식에서는 자원을 사용하기 전에 잠금을 설정하고, 사용 후에는 잠금을 해제합니다. 이 접근 방식은 이해하기 쉽고 구현이 간단하지만, 데드락과 같은 문제가 발생할 수 있습니다.
    
2. **Lock-Free Programs**:
    
    잠금을 사용하지 않고도 여러 스레드가 동시에 데이터를 안전하게 조작할 수 있도록 하는 프로그램입니다. 이 방식에서는 스레드가 특정 자원을 기다리지 않으므로 데드락이 발생하지 않습니다. 대신, CAS(Compare-And-Swap)와 같은 원자적 연산을 사용하여 동기화를 보장합니다.
    
    > CAS: 메모리 위치의 값을 확인(Compare)하고, 예상되는 값이 현재 메모리 위치에 저장된 값과 일치하는 경우에만 새로운 값으로 업데이트(Swap)하는 것
    > 
3. **Wait-Free Programs**:
    
    가장 강력한 동기화 보장 수준을 제공하는 프로그램입니다. 이 방식에서는 모든 스레드가 한정된 시간 안에 작업을 완료할 수 있도록 보장합니다. 즉, 각 스레드가 다른 스레드에 의해 방해받지 않고 진행할 수 있습니다. Wait-Free 알고리즘은 복잡하며 성능 오버헤드가 클 수 있습니다.
    

## 현대 OS에선 데드락을 어떻게 처리하는지?

교착 상태를 무시하는 것이 다른 처리 방법과 비교해 비용이 적게 듭니다. 많은 시스템에서 교착 상태는 드물게 발생하기 때문에 교착 상태 처리에 대한 부가적인 비용은 그만한 가치가 없기 때문입니다. 

그러므로, 교착 상태를 처리하는 프로그램을 작성하는 것은 개발자 몫!
