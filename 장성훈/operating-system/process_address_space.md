### 프로세스 주소공간에 대해 설명해 주세요.

프로세스 주소 공간은 운영체제가 각 프로세스에 할당하는 가상 메모리 영역으로, 각 프로세스는 독립적인 주소 공간을 갖습니다. 일반적으로 다음과 같이 구성됩니다:

1. **텍스트(Text) 세그먼트**: 실행할 프로그램 코드가 저장됩니다.
2. **데이터(Data) 세그먼트**: 초기화된 전역 변수와 정적 변수가 저장됩니다.
3. **BSS(Block Started by Symbol) 세그먼트**: 초기화되지 않은 전역 변수와 정적 변수가 저장됩니다.
4. **힙(Heap)**: 동적 메모리 할당에 사용되는 영역으로, 프로그램 실행 중에 `malloc`, `calloc`, `realloc` 등의 함수로 메모리를 할당합니다.
5. **스택(Stack)**: 함수 호출 시 지역 변수와 리턴 주소 등을 저장하는 영역으로, 함수 호출과 반환에 따라 메모리 할당과 해제가 이루어집니다.

자바에선 이렇게 구성됩니다.

1. 텍스트 세그먼트: 
    
    JVM의 클래스 파일 바이트코드가 저장되고 실행되는 영역입니다. 이는 JVM의 Execution Engine이 바이트코드를 실행할 때 사용됩니다.
    
2. 데이터 세그먼트:
    
    초기화된 정적 변수와 클래스 변수 등이 Method Area에 저장됩니다.
    
3. BBS 세그먼트:
    
    자바는 모든 변수를 기본값으로 초기화하므로 BSS 세그먼트가 필요하지 않습니다.
    
4. 힙:
    
    JVM의 힙 영역으로, 동적으로 생성된 객체가 저장됩니다.
    
    `Example example = new Example();`
    
5. 스택 :
    
    JVM의 스택 영역으로, 메소드 호출 시 사용되는 매개변수, 지역 변수, 연산 결과 등이 저장됩니다.
    

### 초기화 하지 않은 변수들은 어디에 저장될까요?

초기화되지 않은 전역 변수와 정적 변수는 BSS(Block Started by Symbol) 세그먼트에 저장됩니다.

자바는 JVM이 초기화되지 않은 변수를 기본값으로 초기화해주기 때문에 BBS 영역이 필요하지 않음.

### Stack과 Heap의 크기는 매우 크다고 할 수 있을까요? 그렇지 않다면, 그 크기는 언제 결정될까요?

스택과 힙의 크기는 매우 크다고 할 수 없습니다. 이들의 크기는 다음과 같이 결정됩니다:

- **스택(Stack)**: 기본 크기는 운영체제와 컴파일러에 의해 결정되지만, 프로그램 실행 중에 동적으로 확장될 수 있습니다. 일반적으로 기본 크기는 제한적이며, 스택 오버플로우를 방지하기 위해 크기 제한이 있습니다.
    - 이용 가능한 공간 이상을 사용하려고 시도
    - 지정된 시스템 메모리 사이즈보다 과다한 스택 메모리 사용(무한 루프에 빠진 재귀 호출)
- **힙(Heap)**: 기본 크기는 운영체제에 의해 결정되지만, 프로그램 실행 중에 동적으로 확장될 수 있습니다. 힙의 크기 제한은 시스템 메모리 용량에 따라 다르며, 동적 메모리 할당 요청에 따라 확장됩니다.

### Stack과 Heap 공간에 대해, 접근 속도가 더 빠른 공간은 어디일까요?

일반적으로 스택(Stack) 공간의 접근 속도가 더 빠릅니다. 스택은 메모리 할당과 해제가 LIFO(Last In, First Out) 방식으로 이루어지며, 연속적인 메모리 영역을 사용하기 때문에 캐시 적중률이 높습니다. 반면, 힙(Heap)은 동적 메모리 할당으로 인해 단편화가 발생할 수 있고, 메모리 접근이 비연속적이어서 캐시 적중률이 낮습니다.

(단편화: 기억장치에 빈공간 or 여러 조각으로 나뉠 수 있음)

### 다음과 같이 공간을 분할하는 이유가 있을까요?

공간을 분할하는 이유는 메모리 관리의 효율성과 안전성을 위해서입니다. 각 세그먼트는 고유한 특성과 용도를 가지며, 이를 분리함으로써 다음과 같은 장점을 얻을 수 있습니다:

- 메모리 보호: 각 세그먼트를 독립적으로 관리하여, 메모리 접근 오류로 인한 문제를 방지합니다.
- 메모리 할당 효율성: 특정 용도의 메모리 영역을 최적화하여 사용합니다.
- 성능 향상: 스택과 힙의 특성을 활용하여 메모리 접근 속도를 최적화합니다.

### 스레드의 주소공간은 어떻게 구성되어 있을까요?

스레드는 동일한 프로세스 내에서 실행되므로, 프로세스의 주소 공간을 공유합니다. 그러나 각 스레드는 독립적인 스택을 가지며, 스택을 통해 함수 호출과 로컬 변수를 관리합니다. 힙, 텍스트, 데이터, BSS 세그먼트는 모든 스레드가 공유합니다.

### "스택"영역과 "힙"영역은 정말 자료구조의 스택/힙과 연관이 있는 걸까요? 만약 그렇다면, 각 주소공간의 동작과정과 연계해서 설명해 주세요.

**메모리 영역**

- 스택(Stack):
    - 함수 호출 시 스택 프레임이 쌓이고, 함수가 종료되면 스택 프레임이 제거됩니다.
    - **LIFO (Last In, First Out)** 방식으로, 빠르게 메모리를 할당하고 해제할 수 있습니다.
- 힙(Heap):
    - 동적 메모리 할당 시, 요청된 메모리 블록이 힙에서 할당됩니다.
    - 크기가 자유로운 메모리 블록을 필요에 따라 할당 및 해제.
    - 상대적으로 느린 메모리 할당 및 해제.

**자료구조**

- 스택:
    - 데이터를 순서대로 저장 및 관리.
    - **LIFO (Last In, First Out)** 구조.
- 힙:
    - 우선순위 큐, 최대 힙, 최소 힙
    - 트리 기반 자료구조(이진 힙 등)

### IPC의 Shared Memory 기법은 프로세스 주소공간의 어디에 들어가나요? 그런 이유가 있을까요?

**IPC(Inter-Process Communication)**

하나의 운영 체제 내에서 실행되는 여러 프로세스가 서로 통신하고 데이터를 교환하는 메커니즘입니다. 

⇒ 파이프, 메시지 큐, 공유 메모리, 세마포어, 소켓, 메모리 맵 파일

**Shared Memory**

두 개 이상의 프로세스가 동일한 메모리 영역을 공유하여 데이터를 주고받는 방법입니다. 

- 공유 메모리는 여러 프로세스가 동시에 접근할 수 있는 메모리 영역을 제공
- 프로세스 간의 빠른 데이터 교환을 가능하게 함(메모리 복사 작업이 필요X)
- shared memory는 공유 영역을 만들고 각 process의 가상 공간에 mapping해서 process간의 자원을 공유한다. ex) POSIX

### 스택과 힙영역의 크기는 언제 결정되나요? 프로그램 개발자가 아닌, 사용자가 이 공간의 크기를 수정할 수 있나요?

사용자는 운영체제의 설정과 환경 변수를 통해 스택과 힙의 크기를 조정할 수 있습니다.

스택과 힙 영역의 크기는 프로그램 실행 시 동적으로 결정되며, 운영체제와 컴파일러에 의해 기본 크기가 설정됩니다. 

- **스택 크기 조정**:
    - `ulimit` 명령어를 사용하여 셸에서 스택 크기를 설정할 수 있습니다.
- **힙 크기 조정**:
    - 프로세스 실행 시, `malloc` 및 `sbrk` 시스템 콜을 통해 힙 크기를 동적으로 조정할 수 있습니다.
    - 특정 환경 변수(예: `MALLOC_ARENA_MAX`)를 설정하여 힙 메모리 관리 방식을 조정할 수 있습니다.

자바에서는 스택과 힙 영역의 크기는 자바 애플리케이션이 실행될 때 결정됩니다. JVM(Java Virtual Machine)은 실행 시점에 특정 옵션을 사용하여 이 두 영역의 크기를 설정할 수 있습니다. 이 설정은 주로 애플리케이션의 메모리 사용 패턴과 성능 요구사항에 따라 조정됩니다.

- 스택 : -Xss
- 힙 : -Xms , -Xmx
    
    (시스템에서 사용하는 메모리 (1g ~ 2g) 정도를 제외하는 것이 좋다.)
    

```java
java -Xss512k -Xms256m -Xmx1024m MyApp
(스택 크기를 512KB로, 초기 힙 크기를 256MB로, 최대 힙 크기를 1024MB로 설정
```

발생할 수 있는 에러

- **OutOfMemoryError: Java heap space**:
    - 힙 공간이 부족할 때 발생하며, 주로 메모리를 과도하게 사용하는 경우나 메모리 누수(memory leak)가 있을 때 발생합니다.
    
    ex) 참조 해제 안된 객체
    
- **OutOfMemoryError: GC overhead limit exceeded**:
    1. Garbage  Collector 가 너무 빈번하게 일어나서 오버헤드가 발생 하는 경우,
    2. Java 프로세스가 GC를 수행하는 시간의 98%를 소비했지만, Heap 메모리의 2% 미만으로 복구되는 경우,
    3. 응용 프로그램이 사용 가능한 거의 모든 메모리를 소진했고, GC가 메모리를 정리하는데 너무 많은 시간과 반복적 실패를 했을 경우
    
    ex) 무한 루프 재귀
