### 멀티프로그래밍

하나의 CPU가 여러 프로세스를 동시에 실행하는 것처럼 보이도록 하는 기법입니다.  프로세스의 CPU 이용을 최대화하여 사용되지 않는 CPU를 최소화하기 위해 프로세스를 적절하게 배치해야하는데, 이를 위해 다양한 스케줄링 큐와 스케줄러가 사용됩니다.

### 스케줄링 큐 (Scheduling Queue)

실행될 프로세스가 여러 개 있으면 하나만 실행되고 나머지는 CPU가 자유로워질 때까지 대기하는 것으로 선입선출의 방식을 따릅니다.

1. **작업 큐, Job Queue**
    - 메모리 할당을 대기 중인 프로세스들로 구성
    - 시스템에서 모든 프로세스들이 존재하는 곳
2. **준비 큐, Ready Queue**
    - 메인 메모리 내에 있으면서 Ready 상태에서 CPU의 할당을 기다리는 프로세스의 집합
3. **장치 큐, Device Queue**
    - 장치 할당을 대기 중인 프로세스들로 구성

### 스케줄러

스케줄러는 프로세스의 상태와 시스템 자원의 사용 상황에 따라 프로세스를 선택하여 실행하는 역할을 합니다.

### 장기 스케줄러(Long-term Scheduler)

작업 스케줄러(Job Scheduler)라고도 불리며, 어떤 프로세스를 Ready Queue로 보낼 지를 결정하는 스케줄러입니다. 디스크에서 하나의 프로그램을 가져와 커널에 등록하면 프로세스가 되는데 이때 디스크에서 어떤 프로그램을 가져와 커널에 등록할지(준비큐에 등록할지) 결정합니다.

- 장기 스케줄러는 수십 초 내지 수 분 단위로 **가끔 호출**되기 때문에 상대적으로 **속도가 느린 것이 허용**
- 장기 스케줄러는 메모리에 동시에 올라가 있는 **프로세스의 수를 조절**하는 역할
- **생성** 상태 관리

> 현대의 시분할 시스템에서 사용되는 운영 체제에는 일반적으로 장기 스케줄러를 두지 않는 경우가 대부분이다. 과거에는 적은 양의 메모리를 많은 프로세스들에게 할당하면 프로세스당 메모리 보유량이 적어져 장기 스케줄러가 이를 조절하는 역할을 했지만 현대의 운영체제 에서는 프로세스가 시작되면 장기 스케줄러 없이 바로 그 프로세스에 메모리를 할당해 준비 큐에 넣어주게 된다.
> 

### **중기 스케줄러(medium term scheduler)**

**메모리**에 적재된 **프로세스 수 관리**

너무 많은 프로세스에게 메모리를 할당해 시스템의 성능이 저하되는 경우 이를 해결하기 위해 메모리에 적재된 프로세스의 수를 동적으로 조절하기 위해 추가된 스케줄러입니다.

- **프로세스 스왑핑(Swapping)을 통한 메모리 관리**
    - 장기 스케줄러와 마찬가지로 메모리에 올라와 있는 **프로세스의 수를 조절하는 역할**
    - 중기 스케줄러는 메모리가 부족할 때 비활성 상태인 프로세스를 하드 디스크의 스왑 영역으로 옮기고, 메모리에 여유가 생기면 다시 메모리로 옮기는 작업을 담당합니다.
        
        만약 메모리에 많은 수의 프로세스가 적재되어 프로세스 당 보유하고 있는 메모리량이 극도로 적어지면 CPU 수행에 당장 필요한 프로세스의 주소 공간조차도 메모리에 올려놓기 어려운 상황이 발생 → 디스크 I/O가 수시로 발생하게 되어 시스템의 성능이 심각하게 저하될 수 있다.
        
- **프로세스 상태 관리**
    - 중기 스케줄러는 프로세스가 대기 상태에서 준비 상태로 전환되는 시점을 관리하여 시스템의 응답성을 높입니다.
    - **중단된 준비, 준비, 중단된 대기, 대기** 상태 관리

### 단기 스케줄러

메모리 내의 준비 상태에 있는 작업 중 **실행 할 프로세스를 선택하여 CPU를 할당**

**CPU스케줄러**라고도 하며 준비 상태의 프로세스 중에서 어던 프로세스를 다음 번에 실행 상태로 만들 것인지를 결정한다. 시분할 시스템에서 타이머 인터럽트가 발생하면 단기 스케줄러가 호출된다.

- **일반적으로 스케줄러**라 함은 단기 스케줄러를 의미하며 단기 스케줄러는 미리 정한 **스케줄링 알고리즘**에 따라 cpu를 할당 할 프로세스를 선택한다.
- 단기 스케줄러는 밀리 세컨트(ms) 이하의 시간 단위로 **매우 빈번하게 호출**되기 때문에 **수행 속도가 충분히 빨라야 한다**.
- **준비, 실행, 대기** 상태 관리

### **현대 OS에는 단기, 중기, 장기 스케쥴러를 모두 사용하고 있나요?**

현대의 운영체제에서는 단기 스케줄러와 중기 스케줄러는 일반적으로 사용되지만, 장기 스케줄러는 일반적으로 사용되지 않습니다. 이는 대부분의 현대 OS가 대화형 시스템(interactive systems)으로 설계되어 사용자가 작업을 시작할 때 즉시 반응하도록 요구되기 때문입니다.

### 프로세스의 스케줄링 상태

프로세스는 다양한 상태를 가지며, 각 상태는 프로세스의 실행 상태를 나타냅니다.

1. **New**: 프로세스가 생성 중인 상태.
2. **Ready**: 실행 준비가 완료된 상태로, CPU 할당을 기다립니다.
3. **Running**: 현재 CPU를 할당받아 실행 중인 상태.
4. **Waiting**: I/O 작업 등으로 인해 대기 중인 상태.
5. **Terminated**: 프로세스 실행이 완료된 상태.

### Preemptive/Non-preemptive에서 존재할 수 없는 상태가 있을까요?

**Asleep(Block)** 상태는 작업 실행이 불가능한 상태로, 자원 할당을 대기 하는 등 사전 정의 된 다른 작업이 완료될 때까지 작업 수행이 중지되는 상태입니다. 따라서 Asleep(Block) 상태는 preemptive 및 non-preemptive 스케줄링 모두에서 존재할 수 없습니다.

### Memory가 부족할 경우, Process는 어떠한 상태로 변화할까요?

- Active(Swapped-in) 상태에서의 Process는 더 이상 작업을 수행할 수 없게 되기 때문에 Swap-out 되어 Suspended(Swapped-out) 상태로 전이됩니다. (중기 스케쥴러에 의해)
- 프로세스가 메모리 할당을 기다리는 상태(Waiting)가 될 수 있습니다.
- 메모리 부족으로 필요한 데이터를 가져올 수 없는 경우 Block가 되어 다른 프로세스가 끝나기를 기다리거나, OS가 프로세스를 강제로 종료시켜 Terminated 상태로 전이됩니다.
